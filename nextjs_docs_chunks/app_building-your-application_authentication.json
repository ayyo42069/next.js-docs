[
  {
    "title": "Authentication",
    "section": "Untitled Section",
    "section_id": "untitled-section",
    "heading_level": 3,
    "content": "Menu\n\nUsing App Router\n\nFeatures available in /app\n\nUsing Latest Version\n\n15.2.4\n\n[App Router](/docs/app)[Building Your Application](/docs/app/building-your-application)Authentication",
    "preview": "Menu Using App Router Features available in /app Using Latest Version 15.2.4 [App Router](/docs/app)[Building Your Application](/docs/app/building-your-application)Authentication",
    "url": "https://nextjs.org/docs/app/building-your-application/authentication#untitled-section",
    "position": 0
  },
  {
    "title": "Authentication",
    "section": "Authentication",
    "section_id": "authentication",
    "heading_level": 1,
    "content": "# Authentication\n\nUnderstanding authentication is crucial for protecting your application's data. This page will guide you through what React and Next.js features to use to implement auth.\n\nBefore starting, it helps to break down the process into three concepts:\n\n1. **[Authentication](#authentication)**: Verifies if the user is who they say they are. It requires the user to prove their identity with something they have, such as a username and password.\n2. **[Session Management](#session-management)**: Tracks the user's auth state across requests.\n3. **[Authorization](#authorization)**: Decides what routes and data the user can access.\n\nThis diagram shows the authentication flow using React and Next.js features:\n\n[Image: Diagram showing the authentication flow with React and Next.js features][Image: Diagram showing the authentication flow with React and Next.js features]\n\nThe examples on this page walk through basic username and password auth for educational purposes. While you can implement a custom auth solution, for increased security and simplicity, we recommend using an authentication library. These offer built-in solutions for authentication, session management, and authorization, as well as additional features such as social logins, multi-factor authentication, and role-based access control. You can find a list in the [Auth Libraries](#auth-libraries) section.",
    "preview": "Understanding authentication is crucial for protecting your application's data. This page will guide you through what React and Next.js features to use to implement auth. Before starting, it helps to break down the process into three concepts: 1. **[Authentication](#authentication)**: Verifies if",
    "url": "https://nextjs.org/docs/app/building-your-application/authentication#authentication",
    "position": 1
  },
  {
    "title": "Authentication",
    "section": "[Authentication](#authentication)",
    "section_id": "authentication-authentication",
    "heading_level": 2,
    "content": "## [Authentication](#authentication)",
    "preview": "## [Authentication](#authentication)",
    "url": "https://nextjs.org/docs/app/building-your-application/authentication#authentication-authentication",
    "position": 2
  },
  {
    "title": "Authentication",
    "section": "[Sign-up and login functionality](#sign-up-and-login-functionality)",
    "section_id": "sign-up-and-login-functionality-sign-up-and-login-functionality",
    "heading_level": 3,
    "content": "### [Sign-up and login functionality](#sign-up-and-login-functionality)\n\nYou can use the [`<form>`](https://react.dev/reference/react-dom/components/form) element with React's [Server Actions](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) and `useActionState` to capture user credentials, validate form fields, and call your Authentication Provider's API or database.\n\nSince Server Actions always execute on the server, they provide a secure environment for handling authentication logic.\n\nHere are the steps to implement signup/login functionality:\n\n#### [1. Capture user credentials](#1-capture-user-credentials)\n\nTo capture user credentials, create a form that invokes a Server Action on submission. For example, a signup form that accepts the user's name, email, and password:\n\napp/ui/signup-form.tsx\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\nimport { signup } from '@/app/actions/auth'\n \nexport function SignupForm() {\n  return (\n    <form action={signup}>\n      <div>\n        <label htmlFor=\"name\">Name</label>\n        <input id=\"name\" name=\"name\" placeholder=\"Name\" />\n      </div>\n      <div>\n        <label htmlFor=\"email\">Email</label>\n        <input id=\"email\" name=\"email\" type=\"email\" placeholder=\"Email\" />\n      </div>\n      <div>\n        <label htmlFor=\"password\">Password</label>\n        <input id=\"password\" name=\"password\" type=\"password\" />\n      </div>\n      <button type=\"submit\">Sign Up</button>\n    </form>\n  )\n}\n```\n\napp/actions/auth.ts\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\nexport async function signup(formData: FormData) {}\n```\n\n#### [2. Validate form fields on the server](#2-validate-form-fields-on-the-server)\n\nUse the Server Action to validate the form fields on the server. If your authentication provider doesn't provide form validation, you can use a schema validation library like [Zod](https://zod.dev/) or [Yup](https://github.com/jquense/yup).\n\nUsing Zod as an example, you can define a form schema with appropriate error messages:\n\napp/lib/definitions.ts\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\nimport { z } from 'zod'\n \nexport const SignupFormSchema = z.object({\n  name: z\n    .string()\n    .min(2, { message: 'Name must be at least 2 characters long.' })\n    .trim(),\n  email: z.string().email({ message: 'Please enter a valid email.' }).trim(),\n  password: z\n    .string()\n    .min(8, { message: 'Be at least 8 characters long' })\n    .regex(/[a-zA-Z]/, { message: 'Contain at least one letter.' })\n    .regex(/[0-9]/, { message: 'Contain at least one number.' })\n    .regex(/[^a-zA-Z0-9]/, {\n      message: 'Contain at least one special character.',\n    })\n    .trim(),\n})\n \nexport type FormState =\n  | {\n      errors?: {\n        name?: string[]\n        email?: string[]\n        password?: string[]\n      }\n      message?: string\n    }\n  | undefined\n```\n\nTo prevent unnecessary calls to your authentication provider's API or database, you can `return` early in the Server Action if any form fields do not match the defined schema.\n\napp/actions/auth.ts\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\nimport { SignupFormSchema, FormState } from '@/app/lib/definitions'\n \nexport async function signup(state: FormState, formData: FormData) {\n  // Validate form fields\n  const validatedFields = SignupFormSchema.safeParse({\n    name: formData.get('name'),\n    email: formData.get('email'),\n    password: formData.get('password'),\n  })\n \n  // If any form fields are invalid, return early\n  if (!validatedFields.success) {\n    return {\n      errors: validatedFields.error.flatten().fieldErrors,\n    }\n  }\n \n  // Call the provider or db to create a user...\n}\n```\n\nBack in your `<SignupForm />`, you can use React's `useActionState` hook to display validation errors while the form is submitting:\n\napp/ui/signup-form.tsx\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\n'use client'\n \nimport { signup } from '@/app/actions/auth'\nimport { useActionState } from 'react'\n \nexport default function SignupForm() {\n  const [state, action, pending] = useActionState(signup, undefined)\n \n  return (\n    <form action={action}>\n      <div>\n        <label htmlFor=\"name\">Name</label>\n        <input id=\"name\" name=\"name\" placeholder=\"Name\" />\n      </div>\n      {state?.errors?.name && <p>{state.errors.name}</p>}\n \n      <div>\n        <label htmlFor=\"email\">Email</label>\n        <input id=\"email\" name=\"email\" placeholder=\"Email\" />\n      </div>\n      {state?.errors?.email && <p>{state.errors.email}</p>}\n \n      <div>\n        <label htmlFor=\"password\">Password</label>\n        <input id=\"password\" name=\"password\" type=\"password\" />\n      </div>\n      {state?.errors?.password && (\n        <div>\n          <p>Password must:</p>\n          <ul>\n            {state.errors.password.map((error) => (\n              <li key={error}>- {error}</li>\n            ))}\n          </ul>\n        </div>\n      )}\n      <button disabled={pending} type=\"submit\">\n        Sign Up\n      </button>\n    </form>\n  )\n}\n```\n\n> **Good to know:**\n>\n> * In React 19, `useFormStatus` includes additional keys on the returned object, like data, method, and action. If you are not using React 19, only the `pending` key is available.\n> * Before mutating data, you should always ensure a user is also authorized to perform the action. See [Authentication and Authorization](#authorization).\n\n#### [3. Create a user or check user credentials](#3-create-a-user-or-check-user-credentials)\n\nAfter validating form fields, you can create a new user account or check if the user exists by calling your authentication provider's API or database.\n\nContinuing from the previous example:\n\napp/actions/auth.tsx\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\nexport async function signup(state: FormState, formData: FormData) {\n  // 1. Validate form fields\n  // ...\n \n  // 2. Prepare data for insertion into database\n  const { name, email, password } = validatedFields.data\n  // e.g. Hash the user's password before storing it\n  const hashedPassword = await bcrypt.hash(password, 10)\n \n  // 3. Insert the user into the database or call an Auth Library's API\n  const data = await db\n    .insert(users)\n    .values({\n      name,\n      email,\n      password: hashedPassword,\n    })\n    .returning({ id: users.id })\n \n  const user = data[0]\n \n  if (!user) {\n    return {\n      message: 'An error occurred while creating your account.',\n    }\n  }\n \n  // TODO:\n  // 4. Create user session\n  // 5. Redirect user\n}\n```\n\nAfter successfully creating the user account or verifying the user credentials, you can create a session to manage the user's auth state. Depending on your session management strategy, the session can be stored in a cookie or database, or both. Continue to the [Session Management](#session-management) section to learn more.\n\n> **Tips:**\n>\n> * The example above is verbose since it breaks down the authentication steps for the purpose of education. This highlights that implementing your own secure solution can quickly become complex. Consider using an [Auth Library](#auth-libraries) to simplify the process.\n> * To improve the user experience, you may want to check for duplicate emails or usernames earlier in the registration flow. For example, as the user types in a username or the input field loses focus. This can help prevent unnecessary form submissions and provide immediate feedback to the user. You can debounce requests with libraries such as [use-debounce](https://www.npmjs.com/package/use-debounce) to manage the frequency of these checks.",
    "preview": "You can use the [`<form>`](https://react.dev/reference/react-dom/components/form) element with React's [Server Actions](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) and `useActionState` to capture user credentials, validate form fields, and call your Authentication",
    "url": "https://nextjs.org/docs/app/building-your-application/authentication#sign-up-and-login-functionality-sign-up-and-login-functionality",
    "position": 3
  },
  {
    "title": "Authentication",
    "section": "[Session Management](#session-management)",
    "section_id": "session-management-session-management",
    "heading_level": 2,
    "content": "## [Session Management](#session-management)\n\nSession management ensures that the user's authenticated state is preserved across requests. It involves creating, storing, refreshing, and deleting sessions or tokens.\n\nThere are two types of sessions:\n\n1. [**Stateless**](#stateless-sessions): Session data (or a token) is stored in the browser's cookies. The cookie is sent with each request, allowing the session to be verified on the server. This method is simpler, but can be less secure if not implemented correctly.\n2. [**Database**](#database-sessions): Session data is stored in a database, with the user's browser only receiving the encrypted session ID. This method is more secure, but can be complex and use more server resources.\n\n> **Good to know:** While you can use either method, or both, we recommend using a session management library such as [iron-session](https://github.com/vvo/iron-session) or [Jose](https://github.com/panva/jose).",
    "preview": "Session management ensures that the user's authenticated state is preserved across requests. It involves creating, storing, refreshing, and deleting sessions or tokens. There are two types of sessions: 1. [**Stateless**](#stateless-sessions): Session data (or a token) is stored in the browser's co",
    "url": "https://nextjs.org/docs/app/building-your-application/authentication#session-management-session-management",
    "position": 4
  },
  {
    "title": "Authentication",
    "section": "[Stateless Sessions](#stateless-sessions)",
    "section_id": "stateless-sessions-stateless-sessions",
    "heading_level": 3,
    "content": "### [Stateless Sessions](#stateless-sessions)\n\nTo create and manage stateless sessions, there are a few steps you need to follow:\n\n1. Generate a secret key, which will be used to sign your session, and store it as an [environment variable](/docs/app/building-your-application/configuring/environment-variables).\n2. Write logic to encrypt/decrypt session data using a session management library.\n3. Manage cookies using the Next.js [`cookies`](/docs/app/api-reference/functions/cookies) API.\n\nIn addition to the above, consider adding functionality to [update (or refresh)](#updating-or-refreshing-sessions) the session when the user returns to the application, and [delete](#deleting-the-session) the session when the user logs out.\n\n> **Good to know:** Check if your [auth library](#auth-libraries) includes session management.\n\n#### [1. Generating a secret key](#1-generating-a-secret-key)\n\nThere are a few ways you can generate secret key to sign your session. For example, you may choose to use the `openssl` command in your terminal:\n\nterminal\n\n```\nopenssl rand -base64 32\n```\n\nThis command generates a 32-character random string that you can use as your secret key and store in your [environment variables file](/docs/app/building-your-application/configuring/environment-variables):\n\n.env\n\n```\nSESSION_SECRET=your_secret_key\n```\n\nYou can then reference this key in your session management logic:\n\napp/lib/session.js\n\n```\nconst secretKey = process.env.SESSION_SECRET\n```\n\n#### [2. Encrypting and decrypting sessions](#2-encrypting-and-decrypting-sessions)\n\nNext, you can use your preferred [session management library](#session-management-libraries) to encrypt and decrypt sessions. Continuing from the previous example, we'll use [Jose](https://www.npmjs.com/package/jose) (compatible with the [Edge Runtime](/docs/app/building-your-application/rendering/edge-and-nodejs-runtimes)) and React's [`server-only`](https://www.npmjs.com/package/server-only) package to ensure that your session management logic is only executed on the server.\n\napp/lib/session.ts\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\nimport 'server-only'\nimport { SignJWT, jwtVerify } from 'jose'\nimport { SessionPayload } from '@/app/lib/definitions'\n \nconst secretKey = process.env.SESSION_SECRET\nconst encodedKey = new TextEncoder().encode(secretKey)\n \nexport async function encrypt(payload: SessionPayload) {\n  return new SignJWT(payload)\n    .setProtectedHeader({ alg: 'HS256' })\n    .setIssuedAt()\n    .setExpirationTime('7d')\n    .sign(encodedKey)\n}\n \nexport async function decrypt(session: string | undefined = '') {\n  try {\n    const { payload } = await jwtVerify(session, encodedKey, {\n      algorithms: ['HS256'],\n    })\n    return payload\n  } catch (error) {\n    console.log('Failed to verify session')\n  }\n}\n```\n\n> **Tips**:\n>\n> * The payload should contain the **minimum**, unique user data that'll be used in subsequent requests, such as the user's ID, role, etc. It should not contain personally identifiable information like phone number, email address, credit card information, etc, or sensitive data like passwords.\n\n#### [3. Setting cookies (recommended options)](#3-setting-cookies-recommended-options)\n\nTo store the session in a cookie, use the Next.js [`cookies`](/docs/app/api-reference/functions/cookies) API. The cookie should be set on the server, and include the recommended options:\n\n* **HttpOnly**: Prevents client-side JavaScript from accessing the cookie.\n* **Secure**: Use https to send the cookie.\n* **SameSite**: Specify whether the cookie can be sent with cross-site requests.\n* **Max-Age or Expires**: Delete the cookie after a certain period.\n* **Path**: Define the URL path for the cookie.\n\nPlease refer to [MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies) for more information on each of these options.\n\napp/lib/session.ts\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\nimport 'server-only'\nimport { cookies } from 'next/headers'\n \nexport async function createSession(userId: string) {\n  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)\n  const session = await encrypt({ userId, expiresAt })\n  const cookieStore = await cookies()\n \n  cookieStore.set('session', session, {\n    httpOnly: true,\n    secure: true,\n    expires: expiresAt,\n    sameSite: 'lax',\n    path: '/',\n  })\n}\n```\n\nBack in your Server Action, you can invoke the `createSession()` function, and use the [`redirect()`](/docs/app/building-your-application/routing/redirecting) API to redirect the user to the appropriate page:\n\napp/actions/auth.ts\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\nimport { createSession } from '@/app/lib/session'\n \nexport async function signup(state: FormState, formData: FormData) {\n  // Previous steps:\n  // 1. Validate form fields\n  // 2. Prepare data for insertion into database\n  // 3. Insert the user into the database or call an Library API\n \n  // Current steps:\n  // 4. Create user session\n  await createSession(user.id)\n  // 5. Redirect user\n  redirect('/profile')\n}\n```\n\n> **Tips**:\n>\n> * **Cookies should be set on the server** to prevent client-side tampering.\n> * \ud83c\udfa5 Watch: Learn more about stateless sessions and authentication with Next.js \u2192 [YouTube (11 minutes)](https://www.youtube.com/watch?v=DJvM2lSPn6w).\n\n#### [Updating (or refreshing) sessions](#updating-or-refreshing-sessions)\n\nYou can also extend the session's expiration time. This is useful for keeping the user logged in after they access the application again. For example:\n\napp/lib/session.ts\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\nimport 'server-only'\nimport { cookies } from 'next/headers'\nimport { decrypt } from '@/app/lib/session'\n \nexport async function updateSession() {\n  const session = (await cookies()).get('session')?.value\n  const payload = await decrypt(session)\n \n  if (!session || !payload) {\n    return null\n  }\n \n  const expires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)\n \n  const cookieStore = await cookies()\n  cookieStore.set('session', session, {\n    httpOnly: true,\n    secure: true,\n    expires: expires,\n    sameSite: 'lax',\n    path: '/',\n  })\n}\n```\n\n> **Tip:** Check if your auth library supports refresh tokens, which can be used to extend the user's session.\n\n#### [Deleting the session](#deleting-the-session)\n\nTo delete the session, you can delete the cookie:\n\napp/lib/session.ts\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\nimport 'server-only'\nimport { cookies } from 'next/headers'\n \nexport async function deleteSession() {\n  const cookieStore = await cookies()\n  cookieStore.delete('session')\n}\n```\n\nThen you can reuse the `deleteSession()` function in your application, for example, on logout:\n\napp/actions/auth.ts\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\nimport { cookies } from 'next/headers'\nimport { deleteSession } from '@/app/lib/session'\n \nexport async function logout() {\n  deleteSession()\n  redirect('/login')\n}\n```",
    "preview": "To create and manage stateless sessions, there are a few steps you need to follow: 1. Generate a secret key, which will be used to sign your session, and store it as an [environment variable](/docs/app/building-your-application/configuring/environment-variables). 2. Write logic to encrypt/decrypt s",
    "url": "https://nextjs.org/docs/app/building-your-application/authentication#stateless-sessions-stateless-sessions",
    "position": 5
  },
  {
    "title": "Authentication",
    "section": "[Database Sessions](#database-sessions)",
    "section_id": "database-sessions-database-sessions",
    "heading_level": 3,
    "content": "### [Database Sessions](#database-sessions)\n\nTo create and manage database sessions, you'll need to follow these steps:\n\n1. Create a table in your database to store session and data (or check if your Auth Library handles this).\n2. Implement functionality to insert, update, and delete sessions\n3. Encrypt the session ID before storing it in the user's browser, and ensure the database and cookie stay in sync (this is optional, but recommended for optimistic auth checks in [Middleware](#optimistic-checks-with-middleware-optional)).\n\nFor example:\n\napp/lib/session.ts\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\nimport cookies from 'next/headers'\nimport { db } from '@/app/lib/db'\nimport { encrypt } from '@/app/lib/session'\n \nexport async function createSession(id: number) {\n  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)\n \n  // 1. Create a session in the database\n  const data = await db\n    .insert(sessions)\n    .values({\n      userId: id,\n      expiresAt,\n    })\n    // Return the session ID\n    .returning({ id: sessions.id })\n \n  const sessionId = data[0].id\n \n  // 2. Encrypt the session ID\n  const session = await encrypt({ sessionId, expiresAt })\n \n  // 3. Store the session in cookies for optimistic auth checks\n  const cookieStore = await cookies()\n  cookieStore.set('session', session, {\n    httpOnly: true,\n    secure: true,\n    expires: expiresAt,\n    sameSite: 'lax',\n    path: '/',\n  })\n}\n```\n\n> **Tips**:\n>\n> * For faster data retrieval, consider using a database like [Vercel Redis](https://vercel.com/docs/storage/vercel-kv). However, you can also keep the session data in your primary database, and combine data requests to reduce the number of queries.\n> * You may opt to use database sessions for more advanced use cases, such as keeping track of the last time a user logged in, or number of active devices, or give users the ability to log out of all devices.\n\nAfter implementing session management, you'll need to add authorization logic to control what users can access and do within your application. Continue to the [Authorization](#authorization) section to learn more.",
    "preview": "To create and manage database sessions, you'll need to follow these steps: 1. Create a table in your database to store session and data (or check if your Auth Library handles this). 2. Implement functionality to insert, update, and delete sessions 3. Encrypt the session ID before storing it in the",
    "url": "https://nextjs.org/docs/app/building-your-application/authentication#database-sessions-database-sessions",
    "position": 6
  },
  {
    "title": "Authentication",
    "section": "[Authorization](#authorization)",
    "section_id": "authorization-authorization",
    "heading_level": 2,
    "content": "## [Authorization](#authorization)\n\nOnce a user is authenticated and a session is created, you can implement authorization to control what the user can access and do within your application.\n\nThere are two main types of authorization checks:\n\n1. **Optimistic**: Checks if the user is authorized to access a route or perform an action using the session data stored in the cookie. These checks are useful for quick operations, such as showing/hiding UI elements or redirecting users based on permissions or roles.\n2. **Secure**: Checks if the user is authorized to access a route or perform an action using the session data stored in the database. These checks are more secure and are used for operations that require access to sensitive data or actions.\n\nFor both cases, we recommend:\n\n* Creating a [Data Access Layer](#creating-a-data-access-layer-dal) to centralize your authorization logic\n* Using [Data Transfer Objects (DTO)](#using-data-transfer-objects-dto) to only return the necessary data\n* Optionally use [Middleware](#optimistic-checks-with-middleware-optional) to perform optimistic checks.",
    "preview": "Once a user is authenticated and a session is created, you can implement authorization to control what the user can access and do within your application. There are two main types of authorization checks: 1. **Optimistic**: Checks if the user is authorized to access a route or perform an action us",
    "url": "https://nextjs.org/docs/app/building-your-application/authentication#authorization-authorization",
    "position": 7
  },
  {
    "title": "Authentication",
    "section": "[Optimistic checks with Middleware (Optional)](#optimistic-checks-with-middleware-optional)",
    "section_id": "optimistic-checks-with-middleware-optional-optimistic-checks-with-middleware-optional",
    "heading_level": 3,
    "content": "### [Optimistic checks with Middleware (Optional)](#optimistic-checks-with-middleware-optional)\n\nThere are some cases where you may want to use [Middleware](/docs/app/building-your-application/routing/middleware) and redirect users based on permissions:\n\n* To perform optimistic checks. Since Middleware runs on every route, it's a good way to centralize redirect logic and pre-filter unauthorized users.\n* To protect static routes that share data between users (e.g. content behind a paywall).\n\nHowever, since Middleware runs on every route, including [prefetched](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching) routes, it's important to only read the session from the cookie (optimistic checks), and avoid database checks to prevent performance issues.\n\nFor example:\n\nmiddleware.ts\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\nimport { NextRequest, NextResponse } from 'next/server'\nimport { decrypt } from '@/app/lib/session'\nimport { cookies } from 'next/headers'\n \n// 1. Specify protected and public routes\nconst protectedRoutes = ['/dashboard']\nconst publicRoutes = ['/login', '/signup', '/']\n \nexport default async function middleware(req: NextRequest) {\n  // 2. Check if the current route is protected or public\n  const path = req.nextUrl.pathname\n  const isProtectedRoute = protectedRoutes.includes(path)\n  const isPublicRoute = publicRoutes.includes(path)\n \n  // 3. Decrypt the session from the cookie\n  const cookie = (await cookies()).get('session')?.value\n  const session = await decrypt(cookie)\n \n  // 4. Redirect to /login if the user is not authenticated\n  if (isProtectedRoute && !session?.userId) {\n    return NextResponse.redirect(new URL('/login', req.nextUrl))\n  }\n \n  // 5. Redirect to /dashboard if the user is authenticated\n  if (\n    isPublicRoute &&\n    session?.userId &&\n    !req.nextUrl.pathname.startsWith('/dashboard')\n  ) {\n    return NextResponse.redirect(new URL('/dashboard', req.nextUrl))\n  }\n \n  return NextResponse.next()\n}\n \n// Routes Middleware should not run on\nexport const config = {\n  matcher: ['/((?!api|_next/static|_next/image|.*\\\\.png$).*)'],\n}\n```\n\nWhile Middleware can be useful for initial checks, it should not be your only line of defense in protecting your data. The majority of security checks should be performed as close as possible to your data source, see [Data Access Layer](#creating-a-data-access-layer-dal) for more information.\n\n> **Tips**:\n>\n> * In Middleware, you can also read cookies using `req.cookies.get('session').value`.\n> * Middleware uses the [Edge Runtime](/docs/app/building-your-application/rendering/edge-and-nodejs-runtimes), check if your Auth library and session management library are compatible.\n> * You can use the `matcher` property in the Middleware to specify which routes Middleware should run on. Although, for auth, it's recommended Middleware runs on all routes.",
    "preview": "There are some cases where you may want to use [Middleware](/docs/app/building-your-application/routing/middleware) and redirect users based on permissions: * To perform optimistic checks. Since Middleware runs on every route, it's a good way to centralize redirect logic and pre-filter unauthorized",
    "url": "https://nextjs.org/docs/app/building-your-application/authentication#optimistic-checks-with-middleware-optional-optimistic-checks-with-middleware-optional",
    "position": 8
  },
  {
    "title": "Authentication",
    "section": "[Creating a Data Access Layer (DAL)](#creating-a-data-access-layer-dal)",
    "section_id": "creating-a-data-access-layer-dal-creating-a-data-access-layer-dal",
    "heading_level": 3,
    "content": "### [Creating a Data Access Layer (DAL)](#creating-a-data-access-layer-dal)\n\nWe recommend creating a DAL to centralize your data requests and authorization logic.\n\nThe DAL should include a function that verifies the user's session as they interact with your application. At the very least, the function should check if the session is valid, then redirect or return the user information needed to make further requests.\n\nFor example, create a separate file for your DAL that includes a `verifySession()` function. Then use React's [cache](https://react.dev/reference/react/cache) API to memoize the return value of the function during a React render pass:\n\napp/lib/dal.ts\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\nimport 'server-only'\n \nimport { cookies } from 'next/headers'\nimport { decrypt } from '@/app/lib/session'\n \nexport const verifySession = cache(async () => {\n  const cookie = (await cookies()).get('session')?.value\n  const session = await decrypt(cookie)\n \n  if (!session?.userId) {\n    redirect('/login')\n  }\n \n  return { isAuth: true, userId: session.userId }\n})\n```\n\nYou can then invoke the `verifySession()` function in your data requests, Server Actions, Route Handlers:\n\napp/lib/dal.ts\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\nexport const getUser = cache(async () => {\n  const session = await verifySession()\n  if (!session) return null\n \n  try {\n    const data = await db.query.users.findMany({\n      where: eq(users.id, session.userId),\n      // Explicitly return the columns you need rather than the whole user object\n      columns: {\n        id: true,\n        name: true,\n        email: true,\n      },\n    })\n \n    const user = data[0]\n \n    return user\n  } catch (error) {\n    console.log('Failed to fetch user')\n    return null\n  }\n})\n```\n\n> **Tip**:\n>\n> * A DAL can be used to protect data fetched at request time. However, for static routes that share data between users, data will be fetched at build time and not at request time. Use [Middleware](#optimistic-checks-with-middleware-optional) to protect static routes.\n> * For secure checks, you can check if the session is valid by comparing the session ID with your database. Use React's [cache](https://react.dev/reference/react/cache) function to avoid unnecessary duplicate requests to the database during a render pass.\n> * You may wish to consolidate related data requests in a JavaScript class that runs `verifySession()` before any methods.",
    "preview": "We recommend creating a DAL to centralize your data requests and authorization logic. The DAL should include a function that verifies the user's session as they interact with your application. At the very least, the function should check if the session is valid, then redirect or return the user inf",
    "url": "https://nextjs.org/docs/app/building-your-application/authentication#creating-a-data-access-layer-dal-creating-a-data-access-layer-dal",
    "position": 9
  },
  {
    "title": "Authentication",
    "section": "[Using Data Transfer Objects (DTO)](#using-data-transfer-objects-dto)",
    "section_id": "using-data-transfer-objects-dto-using-data-transfer-objects-dto",
    "heading_level": 3,
    "content": "### [Using Data Transfer Objects (DTO)](#using-data-transfer-objects-dto)\n\nWhen retrieving data, it's recommended you return only the necessary data that will be used in your application, and not entire objects. For example, if you're fetching user data, you might only return the user's ID and name, rather than the entire user object which could contain passwords, phone numbers, etc.\n\nHowever, if you have no control over the returned data structure, or are working in a team where you want to avoid whole objects being passed to the client, you can use strategies such as specifying what fields are safe to be exposed to the client.\n\napp/lib/dto.ts\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\nimport 'server-only'\nimport { getUser } from '@/app/lib/dal'\n \nfunction canSeeUsername(viewer: User) {\n  return true\n}\n \nfunction canSeePhoneNumber(viewer: User, team: string) {\n  return viewer.isAdmin || team === viewer.team\n}\n \nexport async function getProfileDTO(slug: string) {\n  const data = await db.query.users.findMany({\n    where: eq(users.slug, slug),\n    // Return specific columns here\n  })\n  const user = data[0]\n \n  const currentUser = await getUser(user.id)\n \n  // Or return only what's specific to the query here\n  return {\n    username: canSeeUsername(currentUser) ? user.username : null,\n    phonenumber: canSeePhoneNumber(currentUser, user.team)\n      ? user.phonenumber\n      : null,\n  }\n}\n```\n\nBy centralizing your data requests and authorization logic in a DAL and using DTOs, you can ensure that all data requests are secure and consistent, making it easier to maintain, audit, and debug as your application scales.\n\n> **Good to know**:\n>\n> * There are a couple of different ways you can define a DTO, from using `toJSON()`, to individual functions like the example above, or JS classes. Since these are JavaScript patterns and not a React or Next.js feature, we recommend doing some research to find the best pattern for your application.\n> * Learn more about security best practices in our [Security in Next.js article](/blog/security-nextjs-server-components-actions).",
    "preview": "When retrieving data, it's recommended you return only the necessary data that will be used in your application, and not entire objects. For example, if you're fetching user data, you might only return the user's ID and name, rather than the entire user object which could contain passwords, phone nu",
    "url": "https://nextjs.org/docs/app/building-your-application/authentication#using-data-transfer-objects-dto-using-data-transfer-objects-dto",
    "position": 10
  },
  {
    "title": "Authentication",
    "section": "[Server Components](#server-components)",
    "section_id": "server-components-server-components",
    "heading_level": 3,
    "content": "### [Server Components](#server-components)\n\nAuth check in [Server Components](/docs/app/building-your-application/rendering/server-components) are useful for role-based access. For example, to conditionally render components based on the user's role:\n\napp/dashboard/page.tsx\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\nimport { verifySession } from '@/app/lib/dal'\n \nexport default function Dashboard() {\n  const session = await verifySession()\n  const userRole = session?.user?.role // Assuming 'role' is part of the session object\n \n  if (userRole === 'admin') {\n    return <AdminDashboard />\n  } else if (userRole === 'user') {\n    return <UserDashboard />\n  } else {\n    redirect('/login')\n  }\n}\n```\n\nIn the example, we use the `verifySession()` function from our DAL to check for 'admin', 'user', and unauthorized roles. This pattern ensures that each user interacts only with components appropriate to their role.",
    "preview": "Auth check in [Server Components](/docs/app/building-your-application/rendering/server-components) are useful for role-based access. For example, to conditionally render components based on the user's role: app/dashboard/page.tsx TypeScript JavaScriptTypeScript [Code Block] In the example, we u",
    "url": "https://nextjs.org/docs/app/building-your-application/authentication#server-components-server-components",
    "position": 11
  },
  {
    "title": "Authentication",
    "section": "[Layouts and auth checks](#layouts-and-auth-checks)",
    "section_id": "layouts-and-auth-checks-layouts-and-auth-checks",
    "heading_level": 3,
    "content": "### [Layouts and auth checks](#layouts-and-auth-checks)\n\nDue to [Partial Rendering](/docs/app/building-your-application/routing/linking-and-navigating#4-partial-rendering), be cautious when doing checks in [Layouts](/docs/app/building-your-application/routing/layouts-and-templates) as these don't re-render on navigation, meaning the user session won't be checked on every route change.\n\nInstead, you should do the checks close to your data source or the component that'll be conditionally rendered.\n\nFor example, consider a shared layout that fetches the user data and displays the user image in a nav. Instead of doing the auth check in the layout, you should fetch the user data (`getUser()`) in the layout and do the auth check in your DAL.\n\nThis guarantees that wherever `getUser()` is called within your application, the auth check is performed, and prevents developers forgetting to check the user is authorized to access the data.\n\napp/layout.tsx\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\nexport default async function Layout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  const user = await getUser();\n \n  return (\n    // ...\n  )\n}\n```\n\napp/lib/dal.ts\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\nexport const getUser = cache(async () => {\n  const session = await verifySession()\n  if (!session) return null\n \n  // Get user ID from session and fetch data\n})\n```\n\n> **Good to know:**\n>\n> * A common pattern in SPAs is to `return null` in a layout or a top-level component if a user is not authorized. This pattern is **not recommended** since Next.js applications have multiple entry points, which will not prevent nested route segments and Server Actions from being accessed.",
    "preview": "Due to [Partial Rendering](/docs/app/building-your-application/routing/linking-and-navigating#4-partial-rendering), be cautious when doing checks in [Layouts](/docs/app/building-your-application/routing/layouts-and-templates) as these don't re-render on navigation, meaning the user session won't be",
    "url": "https://nextjs.org/docs/app/building-your-application/authentication#layouts-and-auth-checks-layouts-and-auth-checks",
    "position": 12
  },
  {
    "title": "Authentication",
    "section": "[Server Actions](#server-actions)",
    "section_id": "server-actions-server-actions",
    "heading_level": 3,
    "content": "### [Server Actions](#server-actions)\n\nTreat [Server Actions](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) with the same security considerations as public-facing API endpoints, and verify if the user is allowed to perform a mutation.\n\nIn the example below, we check the user's role before allowing the action to proceed:\n\napp/lib/actions.ts\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\n'use server'\nimport { verifySession } from '@/app/lib/dal'\n \nexport async function serverAction(formData: FormData) {\n  const session = await verifySession()\n  const userRole = session?.user?.role\n \n  // Return early if user is not authorized to perform the action\n  if (userRole !== 'admin') {\n    return null\n  }\n \n  // Proceed with the action for authorized users\n}\n```",
    "preview": "Treat [Server Actions](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) with the same security considerations as public-facing API endpoints, and verify if the user is allowed to perform a mutation. In the example below, we check the user's role before allowing the ac",
    "url": "https://nextjs.org/docs/app/building-your-application/authentication#server-actions-server-actions",
    "position": 13
  },
  {
    "title": "Authentication",
    "section": "[Route Handlers](#route-handlers)",
    "section_id": "route-handlers-route-handlers",
    "heading_level": 3,
    "content": "### [Route Handlers](#route-handlers)\n\nTreat [Route Handlers](/docs/app/building-your-application/routing/route-handlers) with the same security considerations as public-facing API endpoints, and verify if the user is allowed to access the Route Handler.\n\nFor example:\n\napp/api/route.ts\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\nimport { verifySession } from '@/app/lib/dal'\n \nexport async function GET() {\n  // User authentication and role verification\n  const session = await verifySession()\n \n  // Check if the user is authenticated\n  if (!session) {\n    // User is not authenticated\n    return new Response(null, { status: 401 })\n  }\n \n  // Check if the user has the 'admin' role\n  if (session.user.role !== 'admin') {\n    // User is authenticated but does not have the right permissions\n    return new Response(null, { status: 403 })\n  }\n \n  // Continue for authorized users\n}\n```\n\nThe example above demonstrates a Route Handler with a two-tier security check. It first checks for an active session, and then verifies if the logged-in user is an 'admin'.",
    "preview": "Treat [Route Handlers](/docs/app/building-your-application/routing/route-handlers) with the same security considerations as public-facing API endpoints, and verify if the user is allowed to access the Route Handler. For example: app/api/route.ts TypeScript JavaScriptTypeScript [Code Block] The",
    "url": "https://nextjs.org/docs/app/building-your-application/authentication#route-handlers-route-handlers",
    "position": 14
  },
  {
    "title": "Authentication",
    "section": "[Context Providers](#context-providers)",
    "section_id": "context-providers-context-providers",
    "heading_level": 2,
    "content": "## [Context Providers](#context-providers)\n\nUsing context providers for auth works due to [interleaving](/docs/app/building-your-application/rendering/composition-patterns#interleaving-server-and-client-components). However, React `context` is not supported in Server Components, making them only applicable to Client Components.\n\nThis works, but any child Server Components will be rendered on the server first, and will not have access to the context provider\u2019s session data:\n\napp/layout.ts\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\nimport { ContextProvider } from 'auth-lib'\n \nexport default function RootLayout({ children }) {\n  return (\n    <html lang=\"en\">\n      <body>\n        <ContextProvider>{children}</ContextProvider>\n      </body>\n    </html>\n  )\n}\n```\n\n```\n\"use client\";\n \nimport { useSession } from \"auth-lib\";\n \nexport default function Profile() {\n  const { userId } = useSession();\n  const { data } = useSWR(`/api/user/${userId}`, fetcher)\n \n  return (\n    // ...\n  );\n}\n```\n\nIf session data is needed in Client Components (e.g. for client-side data fetching), use React\u2019s [`taintUniqueValue`](https://react.dev/reference/react/experimental_taintUniqueValue) API to prevent sensitive session data from being exposed to the client.",
    "preview": "Using context providers for auth works due to [interleaving](/docs/app/building-your-application/rendering/composition-patterns#interleaving-server-and-client-components). However, React `context` is not supported in Server Components, making them only applicable to Client Components. This works, b",
    "url": "https://nextjs.org/docs/app/building-your-application/authentication#context-providers-context-providers",
    "position": 15
  },
  {
    "title": "Authentication",
    "section": "[Resources](#resources)",
    "section_id": "resources-resources",
    "heading_level": 2,
    "content": "## [Resources](#resources)\n\nNow that you've learned about authentication in Next.js, here are Next.js-compatible libraries and resources to help you implement secure authentication and session management:",
    "preview": "Now that you've learned about authentication in Next.js, here are Next.js-compatible libraries and resources to help you implement secure authentication and session management:",
    "url": "https://nextjs.org/docs/app/building-your-application/authentication#resources-resources",
    "position": 16
  },
  {
    "title": "Authentication",
    "section": "[Auth Libraries](#auth-libraries)",
    "section_id": "auth-libraries-auth-libraries",
    "heading_level": 3,
    "content": "### [Auth Libraries](#auth-libraries)\n\n* [Auth0](https://auth0.com/docs/quickstart/webapp/nextjs/01-login)\n* [Clerk](https://clerk.com/docs/quickstarts/nextjs)\n* [Kinde](https://kinde.com/docs/developer-tools/nextjs-sdk)\n* [Logto](https://docs.logto.io/quick-starts/next-app-router)\n* [NextAuth.js](https://authjs.dev/getting-started/installation?framework=next.js)\n* [Ory](https://www.ory.sh/docs/getting-started/integrate-auth/nextjs)\n* [Stack Auth](https://docs.stack-auth.com/getting-started/setup)\n* [Supabase](https://supabase.com/docs/guides/getting-started/quickstarts/nextjs)\n* [Stytch](https://stytch.com/docs/guides/quickstarts/nextjs)\n* [WorkOS](https://workos.com/docs/user-management/nextjs)",
    "preview": "* [Auth0](https://auth0.com/docs/quickstart/webapp/nextjs/01-login) * [Clerk](https://clerk.com/docs/quickstarts/nextjs) * [Kinde](https://kinde.com/docs/developer-tools/nextjs-sdk) * [Logto](https://docs.logto.io/quick-starts/next-app-router) * [NextAuth.js](https://authjs.dev/getting-started/insta",
    "url": "https://nextjs.org/docs/app/building-your-application/authentication#auth-libraries-auth-libraries",
    "position": 17
  },
  {
    "title": "Authentication",
    "section": "[Session Management Libraries](#session-management-libraries)",
    "section_id": "session-management-libraries-session-management-libraries",
    "heading_level": 3,
    "content": "### [Session Management Libraries](#session-management-libraries)\n\n* [Iron Session](https://github.com/vvo/iron-session)\n* [Jose](https://github.com/panva/jose)",
    "preview": "* [Iron Session](https://github.com/vvo/iron-session) * [Jose](https://github.com/panva/jose)",
    "url": "https://nextjs.org/docs/app/building-your-application/authentication#session-management-libraries-session-management-libraries",
    "position": 18
  },
  {
    "title": "Authentication",
    "section": "[Further Reading](#further-reading)",
    "section_id": "further-reading-further-reading",
    "heading_level": 2,
    "content": "## [Further Reading](#further-reading)\n\nTo continue learning about authentication and security, check out the following resources:\n\n* [How to think about security in Next.js](/blog/security-nextjs-server-components-actions)\n* [Understanding XSS Attacks](https://vercel.com/guides/understanding-xss-attacks)\n* [Understanding CSRF Attacks](https://vercel.com/guides/understanding-csrf-attacks)\n* [The Copenhagen Book](https://thecopenhagenbook.com/)\n\nWas this helpful?\n\nsupported.\n\nSend",
    "preview": "To continue learning about authentication and security, check out the following resources: * [How to think about security in Next.js](/blog/security-nextjs-server-components-actions) * [Understanding XSS Attacks](https://vercel.com/guides/understanding-xss-attacks) * [Understanding CSRF Attacks](ht",
    "url": "https://nextjs.org/docs/app/building-your-application/authentication#further-reading-further-reading",
    "position": 19
  }
]